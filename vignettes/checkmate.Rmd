---
title: "Checkmate"
author: "Michel Lang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{checkmate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r,include=FALSE}
library(checkmate)
```

Ever used an R function that produced a not-very-helpful error message, just to discover after minutes of debugging that you simply passed a wrong argument?

Blaming the laziness of the package author for not doing such standard checks (in a dynamically typed language such as R) is at least partially unfair, as R makes theses types of checks cumbersome and annoying. Well, that's how it was in the past.

Enter checkmate.

Virtually **every standard type of user error** when passing arguments into function can be caught with a simple, readable line which produces an **informative error message** in case.
A substantial part of the package was written in C to **minimize any worries about execution time overhead**.

## Intro
As a motivational example, consider you have a function to calculate the faculty of a natural number and the user may choose between using either the stirling approximation or R's `factorial` function (which internally uses the gamma function).
Thus, you have two arguments, `n` and `method`.
Argument `n` must obviously be a positive natural number and `method` must be either `"stirling"` or `"factorial"`.
Here is a version of all the hoops you need to jump through to ensure that these simple requirements are met:
```{r}
fact <- function(n, method = "stirling") {
  if (length(n) != 1)
    stop("Argument 'n' must have length 1")
  if (!is.numeric(n))
    stop("Argument 'n' must be numeric")
  if (is.na(n))
    stop("Argument 'n' may not be NA")
  if (is.double(n)) {
    if (is.nan(n))
      stop("Argument 'n' may not be NaN")
    if (is.infinite(n))
      stop("Argument 'n' must be finite")
    if (abs(n - round(n, 0)) > sqrt(.Machine$double.eps))
      stop("Argument 'n' must be an integerish value")
    n <- as.integer(n)
  }
  if (n < 0)
    stop("Argument 'n' must be >= 0")
  if (length(method) != 1)
    stop("Argument 'method' must have length 1")
  if (!is.character(method) || !method %in% c("stirling", "factorial"))
    stop("Argument 'method' must be either 'stirling' or 'factorial'")

  if (method == "factorial")
    factorial(n)
  else
    sqrt(2 * pi * n) * (n / exp(1))^n
}
```
And for comparison, here is the same function using checkmate:
```{r}
fact <- function(n, method = "stirling") {
  assertCount(n)
  assertChoice(method, c("stirling", "factorial"))

  if (method == "factorial")
    factorial(n)
  else
    sqrt(2 * pi * n) * (n / exp(1))^n
}
```

## Function overview
The functions can be split into four functional groups, indicated by their prefix.

If prefixed with `assert`, an error is thrown if the corresponding check fails.
Otherwise, the checked object is returned invisibly.
There are many different coding styles out there in the wild, but most R programmers stick to either `CamelCase` or `underscore_case`.
Therefore, `checkmate` offers all assert functions in both flavors: `assert_count` is just an alias for `assertCount` but allows you to retain your favorite style.

The family of functions prefixed with `test` always return the check result as logical value.
Again, you can use `test_count` and `testCount` interchangeably.

Functions starting with `check` return the error message as a string (or `TRUE` otherwise) and can be used if you need more control and, e.g., want to grep on the returned error message.
Note that this is a feature only very few advanced users need and `checkmate` currently only provides a CamelCase variant.

`expect` is the last family of functions and is intended to be used with the [testthat package](http://cran.r-project.org/package=testthat).
All performed checks are logged into the `testthat` reporter.
Because `testthat` uses the `underscore_case`, the extension functions only come in this flavor.


### Scalars

* [checkFlag](https://mllg.github.io/checkmate/checkFlag)
* [checkCount](https://mllg.github.io/checkmate/checkCount)
* [checkInt](https://mllg.github.io/checkmate/checkInt)
* [checkNumber](https://mllg.github.io/checkmate/checkNumber)
* [checkString](https://mllg.github.io/checkmate/checkString)
* [checkScalar](https://mllg.github.io/checkmate/checkScalar)
* [checkScalarNA](https://mllg.github.io/checkmate/checkScalarNA)


### Vectors

* [checkLogical](https://mllg.github.io/checkmate/checkLogical)
* [checkNumeric](https://mllg.github.io/checkmate/checkNumeric)
* [checkInteger](https://mllg.github.io/checkmate/checkInteger)
* [checkIntegerish](https://mllg.github.io/checkmate/checkIntegerish)
* [checkComplex](https://mllg.github.io/checkmate/checkComplex)
* [checkCharacter](https://mllg.github.io/checkmate/checkCharacter)
* [checkFactor](https://mllg.github.io/checkmate/checkFactor)
* [checkList](https://mllg.github.io/checkmate/checkList)
* [checkVector](https://mllg.github.io/checkmate/checkVector)
* [checkAtomic](https://mllg.github.io/checkmate/checkAtomic)
* [checkAtomicVector](https://mllg.github.io/checkmate/checkAtomicVector)


### Attributes

* [checkClass](https://mllg.github.io/checkmate/checkClass)
* [checkNames](https://mllg.github.io/checkmate/checkNames)
* [checkNamed](https://mllg.github.io/checkmate/checkNamed)


### Choices and Subsets

* [checkChoice](https://mllg.github.io/checkmate/checkChoice)
* [checkSubset](https://mllg.github.io/checkmate/checkSubset)
* [checkSetEqual](https://mllg.github.io/checkmate/checkSetEqual)


### Matrices, Arrays and Data Frame

* [checkMatrix](https://mllg.github.io/checkmate/checkMatrix)
* [checkArray](https://mllg.github.io/checkmate/checkArray)
* [checkDataFrame](https://mllg.github.io/checkmate/checkDataFrame)
* [checkDataTable](https://mllg.github.io/checkmate/checkDataTable)


### Safe Coercion to integer

* [asCount](https://mllg.github.io/checkmate/asInteger)
* [asInt](https://mllg.github.io/checkmate/asInteger)
* [asInteger](https://mllg.github.io/checkmate/asInteger)


### Other builtin

* [checkNull](https://mllg.github.io/checkmate/checkNull)
* [checkEnvironment](https://mllg.github.io/checkmate/checkEnvironment)
* [checkFunction](https://mllg.github.io/checkmate/checkFunction)


### File IO:

* [checkFile](https://mllg.github.io/checkmate/checkFile)
* [checkDirectory](https://mllg.github.io/checkmate/checkDirectory)
* [checkPathForOutput](https://mllg.github.io/checkmate/checkPathForOutput)


## In case you miss flexibility

You can use [assert](https://mllg.github.io/checkmate/assert) to perform multiple checks at once and throw an assertion if all checks fail.


## Argument Checks for the Lazy

The following functions allow a special syntax to define argument checks using a special pattern.
E.g., `qassert(x, "I+")` asserts that `x` is an integer vector with at least one element and no missing values.
This provide a completely alternative mini-language (or style) how to perform argument checks.
You choose what you like best.

* [qassert](https://mllg.github.io/checkmate/qassert)
* [qassertr](https://mllg.github.io/checkmate/qassert)


## checkmate as testthat extension
To extend [testthat](http://cran.r-project.org/package=testthat), you need to IMPORT, DEPEND or SUGGEST on the `checkmate` package.
Here is a minimal example:
```{r,eval=FALSE}
# file: tests/test-all.R
library(testthat)
library(checkmate) # for testthat extensions
test_check("mypkg")
```
Now you are all set and can use more than 30 new expectations in your tests.
```{r,eval=FALSE}
test_that("checkmate is a sweet extension for testthat", {
  x = runif(100)
  expect_numeric(x, len = 100, any.missing = FALSE, lower = 0, upper = 1)
  # or, equivalent, using the lazy style:
  qexpect(x, "N100[0,1]")
})
```

## Speed considerations

In comparison with tediously writing the checks yourself in R (c.f. factorial example at the beginning of the vignette), R is sometimes a tad faster while performing checks on scalars.
This seems odd at first, because checkmate is mostly written in C and should be comparably fast.
Yet many of the functions in the `base` package are not regular functions, but primitives.
While primitives jump directly into the C code, checkmate has to use the considerably slower `.Call` interface.
As a result, it is possible to write (very simple) checks using only the base functions which, under some circumstances, slightly outperform checkmate.
However, if you go one step further and wrap the custom check into a function to convenient re-use it, the performance gain is often lost (see benchmark 1).

For larger objects the tide has turned because checkmate avoids many unnecessary intermediate variables.
Also note that the quick/lazy implementation in `qassert`/`qtest`/`qexpect` is often a tad faster because only two arguments have to be evaluated (the object and the rule) to determine the set of checks to perform.

Below you find some (probably unrepresentative) benchmark.
But also note that this one here has been executed from inside `knitr` which is often the cause for outliers in the measured execution time.
Better run the benchmark yourself to get unbiased results.


### Benchmark 1: Assert that `x` is a flag

```{r,dev="svg",fig.width=6,fig.height=4}
library(ggplot2)
library(microbenchmark)

x = TRUE
r = function(x, na.ok = FALSE) { stopifnot(is.logical(x), length(x) == 1, na.ok || !is.na(x)) }
cm = function(x) assertFlag(x)
cmq = function(x) qassert(x, "B1")
mb = microbenchmark(r(x), cm(x), cmq(x))
print(mb)
autoplot(mb)
```


### Benchmark 2: Assert that `x` is a numeric of length 1000 with no missing nor NaN values

```{r,dev="svg",fig.width=6,fig.height=4}
x = runif(1000)
r = function(x) stopifnot(is.numeric(x) && length(x) == 1000 && all(!is.na(x) & x >= 0 & x <= 1))
cm = function(x) assertNumeric(x, len = 1000, any.missing = FALSE, lower = 0, upper = 1)
cmq = function(x) qassert(x, "N1000[0,1]")
mb = microbenchmark(r(x), cm(x), cmq(x))
print(mb)
autoplot(mb)
```


### Benchmark 3: Assert that `x` is a character vector with no missing values nor empty strings

```{r,dev="svg",fig.width=6,fig.height=4}
x = sample(letters, 10000, replace = TRUE)
r = function(x) stopifnot(is.character(x) && !any(is.na(x)) && all(nzchar(x)))
cm = function(x) assertCharacter(x, any.missing = FALSE, min.chars = 1)
cmq = function(x) qassert(x, "S+[1,]")
mb = microbenchmark(r(x), cm(x), cmq(x))
print(mb)
autoplot(mb)
```


### Benchmark 4: Assert that `x` is a data frame with no missing values

```{r,dev="svg",fig.width=6,fig.height=4}
N = 10000
x = data.frame(a = runif(N), b = sample(letters[1:5], N, replace = TRUE), c = sample(c(FALSE, TRUE), N, replace = TRUE))
r = function(x) is.data.frame(x) && !any(sapply(x, function(x) any(is.na(x))))
cm = function(x) testDataFrame(x, any.missing = FALSE)
cmq = function(x) qtest(x, "D")
mb = microbenchmark(r(x), cm(x), cmq(x))
print(mb)
autoplot(mb)

# checkmate tries to stop as early as possible
x$a[1] = NA
mb = microbenchmark(r(x), cm(x), cmq(x))
print(mb)
autoplot(mb)
```

## Calling checkmate from C/C++

The package registers two functions which can be used in other packages' C/C++ code for argument checks.
```{c,eval=FALSE}
SEXP qassert(SEXP x, const char *rule, const char *name);
Rboolean qtest(SEXP x, const char *rule);
```
These are the counterparts to [qassert](https://mllg.github.io/checkmate/qassert) and [qtest](https://mllg.github.io/checkmate/qassert).
Due to their simplistic interface, they perfectly suit the requirements of most type checks in C/C++.

For detailed background information on the register mechanism, see the [Exporting C Code](http://r-pkgs.had.co.nz/src.html#clang) section in Hadley's Book "R Packages" or [WRE](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Registering-native-routines).
Here is a step-by-step guide to get you started:

1. Add `checkmate` to your "Imports" and LinkingTo" sections in your DESCRIPTION file.
2. Include the provided header file `checkmate.h`.
   Unfortunately, the include is a bit tedious at the moment and you have to make sure to include the header only once.
   To work around this issue, write your own header file "include_checkmate.h" (see below for an example).
3. In every file you want to use `qtest` or `qassert`, include `checkmate.h` or `include_checkmate.h`, respectively.

```{c,eval=FALSE}
/* Examplary header file as workaround for (2) */
#ifndef INCLUDE_CHECKMATE_H_
#define INCLUDE_CHECKMATE_H_
#include <checkmate.h>
#endif
```
```{c,eval=FALSE}
#include "include_checkmate.h"
/* alternative: #include <checkmate.h> */

SEXP double(SEXP x) {
  /* x must be a numeric, not NA and must have length 1 */
  qassert(x, "N1");

  num = REAL(x)[0];
  return ScalarReal(num * num);
}
```

## Session Info
For the sake of completeness, here the `sessionInfo()` for the benchmark (but remember the note before on `knitr` possibly biasing the results).
```{r}
sessionInfo()
```
